{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bar Chart Race \u00b6 Make animated bar chart races in Python with matplotlib. Installation \u00b6 Install with either: pip install bar_chart_race conda install -c conda-forge bar_chart_race Quickstart \u00b6 Must begin with a pandas DataFrame containing 'wide' data where: Every row represents a single period of time Each column holds the value for a particular category The index contains the time component (optional) The data below is an example of properly formatted data. It shows total deaths from COVID-19 for several countries by date. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-08 2240 3337 10887 2349 3993 17669 2255 14792 14704 7111 2020-04-09 2523 3339 12228 2607 4110 18279 2403 15447 16553 7993 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629 Main function - bar_chart_race \u00b6 There is one main function, bar_chart_race , which we use to recreate the above video. All of the parameters are shown below. import bar_chart_race as bcr df = bcr . load_dataset ( 'covid19_tutorial' ) bcr . bar_chart_race ( df = df , filename = 'covid19_horiz.mp4' , orientation = 'h' , sort = 'desc' , n_bars = 6 , fixed_order = False , fixed_max = True , steps_per_period = 10 , interpolate_period = False , label_bars = True , bar_size =. 95 , period_label = { 'x' : . 99 , 'y' : . 25 , 'ha' : 'right' , 'va' : 'center' }, period_fmt = '%B %d , %Y' , period_summary_func = lambda v , r : { 'x' : . 99 , 'y' : . 18 , 's' : f 'Total deaths: { v . nlargest ( 6 ) . sum () : ,.0f } ' , 'ha' : 'right' , 'size' : 8 , 'family' : 'Courier New' }, perpendicular_bar_func = 'median' , period_length = 500 , figsize = ( 5 , 3 ), dpi = 144 , cmap = 'dark12' , title = 'COVID-19 Deaths by Country' , title_size = '' , bar_label_size = 7 , tick_label_size = 7 , shared_fontdict = { 'family' : 'Helvetica' , 'color' : '.1' }, scale = 'linear' , writer = None , fig = None , bar_kwargs = { 'alpha' : . 7 }, filter_column_colors = False ) Save animation to disk or embed into a Jupyter Notebook \u00b6 If you are working within a Jupyter Notebook leave the filename as None and it will be automatically embedded into a Jupyter Notebook. bcr_html = bcr . bar_chart_race ( df = df , filename = None ) Customization \u00b6 There are many options to customize the bar chart race to get the animation you desire. Below, we have an animation where the maximum x-value and order of the bars are set for the entire duration. A custom summary label and perpendicular bar of median is also added. def period_summary ( values , ranks ): top2 = values . nlargest ( 2 ) leader = top2 . index [ 0 ] lead = top2 . iloc [ 0 ] - top2 . iloc [ 1 ] s = f ' { leader } by { lead : .0f } ' return { 's' : s , 'x' : . 95 , 'y' : . 07 , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df_baseball , period_length = 1000 , fixed_max = True , fixed_order = True , n_bars = 10 , figsize = ( 5 , 3 ), period_fmt = 'Season {x:,.0f} ' , title = 'Top 10 Home Run Hitters by Season Played' )","title":"Home"},{"location":"#bar-chart-race","text":"Make animated bar chart races in Python with matplotlib.","title":"Bar Chart Race"},{"location":"#installation","text":"Install with either: pip install bar_chart_race conda install -c conda-forge bar_chart_race","title":"Installation"},{"location":"#quickstart","text":"Must begin with a pandas DataFrame containing 'wide' data where: Every row represents a single period of time Each column holds the value for a particular category The index contains the time component (optional) The data below is an example of properly formatted data. It shows total deaths from COVID-19 for several countries by date. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-08 2240 3337 10887 2349 3993 17669 2255 14792 14704 7111 2020-04-09 2523 3339 12228 2607 4110 18279 2403 15447 16553 7993 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629","title":"Quickstart"},{"location":"#main-function-bar_chart_race","text":"There is one main function, bar_chart_race , which we use to recreate the above video. All of the parameters are shown below. import bar_chart_race as bcr df = bcr . load_dataset ( 'covid19_tutorial' ) bcr . bar_chart_race ( df = df , filename = 'covid19_horiz.mp4' , orientation = 'h' , sort = 'desc' , n_bars = 6 , fixed_order = False , fixed_max = True , steps_per_period = 10 , interpolate_period = False , label_bars = True , bar_size =. 95 , period_label = { 'x' : . 99 , 'y' : . 25 , 'ha' : 'right' , 'va' : 'center' }, period_fmt = '%B %d , %Y' , period_summary_func = lambda v , r : { 'x' : . 99 , 'y' : . 18 , 's' : f 'Total deaths: { v . nlargest ( 6 ) . sum () : ,.0f } ' , 'ha' : 'right' , 'size' : 8 , 'family' : 'Courier New' }, perpendicular_bar_func = 'median' , period_length = 500 , figsize = ( 5 , 3 ), dpi = 144 , cmap = 'dark12' , title = 'COVID-19 Deaths by Country' , title_size = '' , bar_label_size = 7 , tick_label_size = 7 , shared_fontdict = { 'family' : 'Helvetica' , 'color' : '.1' }, scale = 'linear' , writer = None , fig = None , bar_kwargs = { 'alpha' : . 7 }, filter_column_colors = False )","title":"Main function - bar_chart_race"},{"location":"#save-animation-to-disk-or-embed-into-a-jupyter-notebook","text":"If you are working within a Jupyter Notebook leave the filename as None and it will be automatically embedded into a Jupyter Notebook. bcr_html = bcr . bar_chart_race ( df = df , filename = None )","title":"Save animation to disk or embed into a Jupyter Notebook"},{"location":"#customization","text":"There are many options to customize the bar chart race to get the animation you desire. Below, we have an animation where the maximum x-value and order of the bars are set for the entire duration. A custom summary label and perpendicular bar of median is also added. def period_summary ( values , ranks ): top2 = values . nlargest ( 2 ) leader = top2 . index [ 0 ] lead = top2 . iloc [ 0 ] - top2 . iloc [ 1 ] s = f ' { leader } by { lead : .0f } ' return { 's' : s , 'x' : . 95 , 'y' : . 07 , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df_baseball , period_length = 1000 , fixed_max = True , fixed_order = True , n_bars = 10 , figsize = ( 5 , 3 ), period_fmt = 'Season {x:,.0f} ' , title = 'Top 10 Home Run Hitters by Season Played' )","title":"Customization"},{"location":"api/","text":"bar_chart_race API documentation .flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^=\"header-\"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink} @media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}} @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:\" (\" attr(href) \")\";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:\" (\" attr(title) \")\"}.ir a:after,a[href^=\"javascript:\"]:after,a[href^=\"#\"]:after{content:\"\"}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}} Package bar_chart_race Expand source code from ._make_chart import bar_chart_race, load_dataset, prepare_wide_data, prepare_long_data __version__ = \"0.0.7\" all = ['bar_chart_race', 'load_dataset', 'prepare_wide_data', 'prepare_long_data'] Functions def bar_chart_race ( df, filename=None, orientation='h', sort='desc', n_bars=None, fixed_order=False, fixed_max=False, steps_per_period=10, period_length=500, interpolate_period=False, label_bars=True, bar_size=0.95, period_label=True, period_fmt=None, period_summary_func=None, perpendicular_bar_func=None, figsize=(6, 3.5), cmap='dark24', title=None, title_size=None, bar_label_size=7, tick_label_size=7, shared_fontdict=None, scale='linear', writer=None, fig=None, dpi=144, bar_kwargs=None, filter_column_colors=False) Create an animated bar chart race using matplotlib. Data must be in 'wide' format where each row represents a single time period and each column represents a distinct category. Optionally, the index can label the time period. Bar height and location change linearly from one time period to the next. If no filename is given, an HTML string is returned, otherwise the animation is saved to disk. You must have ffmpeg installed on your machine to save files to disk. Get ffmpeg here: https://www.ffmpeg.org/download.html To save .gif files you'll need to install ImageMagick. This is resource intensive - Start with just a few rows of data to test. Parameters df :\u2002 pandas DataFrame Must be a 'wide' DataFrame where each row represents a single period of time. Each column contains the values of the bars for that category. Optionally, use the index to label each time period. The index can be of any type. filename :\u2002 None or str , default None If None return animation as an HTML5 string. If a string, save animation to that filename location. Use .mp4, .gif, .html, .mpeg, .mov and any other extensions supported by ffmpeg or ImageMagick. orientation :\u2002 'h' or 'v' , default 'h' Bar orientation - horizontal or vertical sort :\u2002 'desc' or 'asc' , default 'desc' Choose how to sort the bars. Use 'desc' to put largest bars on top and 'asc' to place largest bars on bottom. n_bars :\u2002 int , default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the edge of the axes. fixed_order :\u2002 bool or list , default False When False , bar order changes every time period to correspond with sort . When True , bars remained fixed according to their final value corresponding with sort . Otherwise, provide a list of the exact order of the categories for the entire duration. fixed_max :\u2002 bool , default False Whether to fix the maximum value of the axis containing the values. When False , the axis for the values will have its maximum (xlim/ylim) just after the largest bar of the current time period. The axis maximum will change along with the data. When True, the maximum axis value will remain constant for the duration of the animation. For example, in a horizontal bar chart, if the largest bar has a value of 100 for the first time period and 10,000 for the last time period. The xlim maximum will be 10,000 for each frame. steps_per_period :\u2002 int , default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. period_length :\u2002 int , default 500 Number of milliseconds to animate each period (row). Default is 500ms (half of a second) interpolate_period :\u2002 bool , default False Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to True , for example, the two consecutive periods 2020-03-29 and 2020-03-30 with steps_per_period set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 label_bars :\u2002 bool , default True Whether to label the bars with their value on their right bar_size :\u2002 float , default .95 Height/width of bars for horizontal/vertical bar charts. Use a number between 0 and 1 Represents the fraction of space that each bar takes up. When equal to 1, no gap remains between the bars. period_label :\u2002 bool or dict , default True If True or dict, use the index as a large text label on the axes whose value changes Use a dictionary to supply the exact position of the period along with any valid parameters of the matplotlib text method. At a minimum, you must supply both 'x' and 'y' in axes coordinates Example: { 'x': .99, 'y': .8, 'ha': 'right', 'va': 'center' } If False - don't place label on axes period_fmt :\u2002 str , default None Either a string with date directives or a new-style (Python 3.6+) formatted string For a string with a date directive, find the complete list here https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes Example of string with date directives '%B %d, %Y' Will change 2020/03/29 to March 29, 2020 For new-style formatted string. Use curly braces and the variable x , which will be passed the current period's index value. Example: 'Period {x:10.2f}' Date directives will only be used for datetime indexes. period_summary_func :\u2002 function , default None Custom text added to the axes each period. Create a user-defined function that accepts two pandas Series of the current time period's values and ranks. It must return a dictionary containing at a minimum the keys \"x\", \"y\", and \"s\" which will be passed to the matplotlib text method. Example: def func(values, ranks): total = values.sum() s = f'Worldwide deaths: {total}' return {'x': .85, 'y': .2, 's': s, 'ha': 'right', 'size': 11} perpendicular_bar_func :\u2002 function or str , default None Creates a single bar perpendicular to the main bars that spans the length of the axis. Use either a string that the DataFrame agg method understands or a user-defined function. DataFrame strings - 'mean', 'median', 'max', 'min', etc.. The function is passed two pandas Series of the current time period's data and ranks. It must return a single value. def func(values, ranks): return values.quantile(.75) figsize :\u2002 two-item tuple of numbers , default (6, 3.5) matplotlib figure size in inches. Will be overridden if figure supplied to fig . cmap :\u2002 str, matplotlib colormap instance, or list of colors , default 'dark24' Colors to be used for the bars. All matplotlib and plotly colormaps are available by string name. Colors will repeat if there are more bars than colors. title :\u2002 str , default None Title of plot title_size :\u2002 number or str , default plt.rcParams['axes.titlesize'] Size in points of title or relative size str. See Font Help below. bar_label_size :\u2002 number or str , default 7 Size in points or relative size str of numeric labels just outside of the bars. See Font Help below. tick_label_size :\u2002 number or str , default 7 Size in points of tick labels. See Font Help below. See Font Help below shared_fontdict :\u2002 dict , default None Dictionary of font properties shared across the tick labels, bar labels, period labels, and title. The only property not shared is size . It will be ignored if you try to set it. Possible keys are: 'family', 'weight', 'color', 'style', 'stretch', 'weight', 'variant' Here is an example dictionary: { 'family' : 'Helvetica', 'weight' : 'bold', 'color' : 'rebeccapurple' } scale :\u2002 'linear' or 'log' , default 'linear' Type of scaling to use for the axis containing the values writer :\u2002 str or matplotlib Writer instance This argument is passed to the matplotlib FuncAnimation.save method. By default, the writer will be 'ffmpeg' unless creating a gif, then it will be 'imagemagick', or an html file, then it will be 'html'. Find all of the availabe Writers: from matplotlib import animation animation.writers.list() You must have ffmpeg or ImageMagick installed in order fig :\u2002 matplotlib Figure , default None For greater control over the aesthetics, supply your own figure. dpi :\u2002 int , default 144 Dots per Inch of the matplotlib figure bar_kwargs :\u2002 dict , default None</code> (alpha=.8) Other keyword arguments (within a dictionary) forwarded to the matplotlib barh / bar function. If no value for 'alpha' is given, then it is set to .8 by default. Some examples: ec - edgecolor - color of edge of bar. Default is 'white' lw - width of edge in points. Default is 1.5 alpha - opacity of bars, 0 to 1 filter_column_colors :\u2002 bool , default False When setting n_bars, it's possible that some columns never appear in the animation. Regardless, all columns get assigned a color by default. For instance, suppose you have 100 columns in your DataFrame, set n_bars to 10, and 15 different columns make at least one appearance in the animation. Even if your colormap has at least 15 colors, it's possible that many bars will be the same color, since each of the 100 columns is assigned of the colormaps colors. Setting this to True will map your colormap to just those columns that make an appearance in the animation, helping avoid duplication of colors. Setting this to True will also have the (possibly unintended) consequence of changing the colors of each color every time a new integer for n_bars is used. EXPERIMENTAL This parameter is experimental and may be changed/removed in a later version. Returns When filename is left as None , an HTML5 video is returned as a string. Otherwise, a file of the animation is saved and None is returned. Notes It is possible for some bars to be out of order momentarily during a transition since both height and location change linearly and not directly with respect to their current value. This keeps all the transitions identical. Examples Use the load_data function to get an example dataset to create an animation. df = bcr.load_dataset('covid19') bcr.bar_chart_race( df=df, filename='covid19_horiz_desc.mp4', orientation='h', sort='desc', n_bars=8, fixed_order=False, fixed_max=True, steps_per_period=10, period_length=500, interpolate_period=False, label_bars=True, bar_size=.95, period_label={'x': .99, 'y': .8, 'ha': 'right', 'va': 'center'}, period_fmt='%B %d, %Y', period_summary_func=lambda v, r: {'x': .85, 'y': .2, 's': f'Total deaths: {v.sum()}', 'ha': 'right', 'size': 11}, perpendicular_bar_func='median', figsize=(5, 3), dpi=144, cmap='dark24', title='COVID-19 Deaths by Country', title_size='', bar_label_size=7, tick_label_size=7, shared_fontdict={'family' : 'Helvetica', 'weight' : 'bold', 'color' : '.1'}, scale='linear', writer=None, fig=None, bar_kwargs={'alpha': .7}, filter_column_colors=False) Font Help Font size can also be a string - 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'smaller', 'larger' These sizes are relative to plt.rcParams['font.size']. Expand source code def bar_chart_race(df, filename=None, orientation='h', sort='desc', n_bars=None, fixed_order=False, fixed_max=False, steps_per_period=10, period_length=500, interpolate_period=False, label_bars=True, bar_size=.95, period_label=True, period_fmt=None, period_summary_func=None, perpendicular_bar_func=None, figsize=(6, 3.5), cmap='dark24', title=None, title_size=None, bar_label_size=7, tick_label_size=7, shared_fontdict=None, scale='linear', writer=None, fig=None, dpi=144, bar_kwargs=None, filter_column_colors=False): ''' Create an animated bar chart race using matplotlib. Data must be in 'wide' format where each row represents a single time period and each column represents a distinct category. Optionally, the index can label the time period. Bar height and location change linearly from one time period to the next. If no `filename` is given, an HTML string is returned, otherwise the animation is saved to disk. You must have ffmpeg installed on your machine to save files to disk. Get ffmpeg here: https://www.ffmpeg.org/download.html To save .gif files you&#39;ll need to install ImageMagick. This is resource intensive - Start with just a few rows of data to test. Parameters ---------- df : pandas DataFrame Must be a &#39;wide&#39; DataFrame where each row represents a single period of time. Each column contains the values of the bars for that category. Optionally, use the index to label each time period. The index can be of any type. filename : `None` or str, default None If `None` return animation as an HTML5 string. If a string, save animation to that filename location. Use .mp4, .gif, .html, .mpeg, .mov and any other extensions supported by ffmpeg or ImageMagick. orientation : &#39;h&#39; or &#39;v&#39;, default &#39;h&#39; Bar orientation - horizontal or vertical sort : &#39;desc&#39; or &#39;asc&#39;, default &#39;desc&#39; Choose how to sort the bars. Use &#39;desc&#39; to put largest bars on top and &#39;asc&#39; to place largest bars on bottom. n_bars : int, default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the edge of the axes. fixed_order : bool or list, default False When `False`, bar order changes every time period to correspond with `sort`. When `True`, bars remained fixed according to their final value corresponding with `sort`. Otherwise, provide a list of the exact order of the categories for the entire duration. fixed_max : bool, default False Whether to fix the maximum value of the axis containing the values. When `False`, the axis for the values will have its maximum (xlim/ylim) just after the largest bar of the current time period. The axis maximum will change along with the data. When True, the maximum axis value will remain constant for the duration of the animation. For example, in a horizontal bar chart, if the largest bar has a value of 100 for the first time period and 10,000 for the last time period. The xlim maximum will be 10,000 for each frame. steps_per_period : int, default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. period_length : int, default 500 Number of milliseconds to animate each period (row). Default is 500ms (half of a second) interpolate_period : bool, default `False` Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to `True`, for example, the two consecutive periods 2020-03-29 and 2020-03-30 with `steps_per_period` set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 label_bars : bool, default `True` Whether to label the bars with their value on their right bar_size : float, default .95 Height/width of bars for horizontal/vertical bar charts. Use a number between 0 and 1 Represents the fraction of space that each bar takes up. When equal to 1, no gap remains between the bars. period_label : bool or dict, default `True` If `True` or dict, use the index as a large text label on the axes whose value changes Use a dictionary to supply the exact position of the period along with any valid parameters of the matplotlib `text` method. At a minimum, you must supply both &#39;x&#39; and &#39;y&#39; in axes coordinates Example: { &#39;x&#39;: .99, &#39;y&#39;: .8, &#39;ha&#39;: &#39;right&#39;, &#39;va&#39;: &#39;center&#39; } If `False` - don&#39;t place label on axes period_fmt : str, default `None` Either a string with date directives or a new-style (Python 3.6+) formatted string For a string with a date directive, find the complete list here https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes Example of string with date directives &#39;%B %d, %Y&#39; Will change 2020/03/29 to March 29, 2020 For new-style formatted string. Use curly braces and the variable `x`, which will be passed the current period&#39;s index value. Example: &#39;Period {x:10.2f}&#39; Date directives will only be used for datetime indexes. period_summary_func : function, default None Custom text added to the axes each period. Create a user-defined function that accepts two pandas Series of the current time period&#39;s values and ranks. It must return a dictionary containing at a minimum the keys &#34;x&#34;, &#34;y&#34;, and &#34;s&#34; which will be passed to the matplotlib `text` method. Example: def func(values, ranks): total = values.sum() s = f&#39;Worldwide deaths: {total}&#39; return {&#39;x&#39;: .85, &#39;y&#39;: .2, &#39;s&#39;: s, &#39;ha&#39;: &#39;right&#39;, &#39;size&#39;: 11} perpendicular_bar_func : function or str, default None Creates a single bar perpendicular to the main bars that spans the length of the axis. Use either a string that the DataFrame `agg` method understands or a user-defined function. DataFrame strings - &#39;mean&#39;, &#39;median&#39;, &#39;max&#39;, &#39;min&#39;, etc.. The function is passed two pandas Series of the current time period&#39;s data and ranks. It must return a single value. def func(values, ranks): return values.quantile(.75) figsize : two-item tuple of numbers, default (6, 3.5) matplotlib figure size in inches. Will be overridden if figure supplied to `fig`. cmap : str, matplotlib colormap instance, or list of colors, default &#39;dark24&#39; Colors to be used for the bars. All matplotlib and plotly colormaps are available by string name. Colors will repeat if there are more bars than colors. title : str, default None Title of plot title_size : number or str, default plt.rcParams[&#39;axes.titlesize&#39;] Size in points of title or relative size str. See Font Help below. bar_label_size : number or str, default 7 Size in points or relative size str of numeric labels just outside of the bars. See Font Help below. tick_label_size : number or str, default 7 Size in points of tick labels. See Font Help below. See Font Help below shared_fontdict : dict, default None Dictionary of font properties shared across the tick labels, bar labels, period labels, and title. The only property not shared is `size`. It will be ignored if you try to set it. Possible keys are: &#39;family&#39;, &#39;weight&#39;, &#39;color&#39;, &#39;style&#39;, &#39;stretch&#39;, &#39;weight&#39;, &#39;variant&#39; Here is an example dictionary: { &#39;family&#39; : &#39;Helvetica&#39;, &#39;weight&#39; : &#39;bold&#39;, &#39;color&#39; : &#39;rebeccapurple&#39; } scale : &#39;linear&#39; or &#39;log&#39;, default &#39;linear&#39; Type of scaling to use for the axis containing the values writer : str or matplotlib Writer instance This argument is passed to the matplotlib FuncAnimation.save method. By default, the writer will be &#39;ffmpeg&#39; unless creating a gif, then it will be &#39;imagemagick&#39;, or an html file, then it will be &#39;html&#39;. Find all of the availabe Writers: >>> from matplotlib import animation >>> animation.writers.list() You must have ffmpeg or ImageMagick installed in order fig : matplotlib Figure, default None For greater control over the aesthetics, supply your own figure. dpi : int, default 144 Dots per Inch of the matplotlib figure bar_kwargs : dict, default `None` (alpha=.8) Other keyword arguments (within a dictionary) forwarded to the matplotlib `barh`/`bar` function. If no value for &#39;alpha&#39; is given, then it is set to .8 by default. Some examples: `ec` - edgecolor - color of edge of bar. Default is &#39;white&#39; `lw` - width of edge in points. Default is 1.5 `alpha` - opacity of bars, 0 to 1 filter_column_colors : bool, default `False` When setting n_bars, it&#39;s possible that some columns never appear in the animation. Regardless, all columns get assigned a color by default. For instance, suppose you have 100 columns in your DataFrame, set n_bars to 10, and 15 different columns make at least one appearance in the animation. Even if your colormap has at least 15 colors, it&#39;s possible that many bars will be the same color, since each of the 100 columns is assigned of the colormaps colors. Setting this to `True` will map your colormap to just those columns that make an appearance in the animation, helping avoid duplication of colors. Setting this to `True` will also have the (possibly unintended) consequence of changing the colors of each color every time a new integer for n_bars is used. EXPERIMENTAL This parameter is experimental and may be changed/removed in a later version. Returns ------- When `filename` is left as `None`, an HTML5 video is returned as a string. Otherwise, a file of the animation is saved and `None` is returned. Notes ----- It is possible for some bars to be out of order momentarily during a transition since both height and location change linearly and not directly with respect to their current value. This keeps all the transitions identical. Examples -------- Use the `load_data` function to get an example dataset to create an animation. df = bcr.load_dataset(&#39;covid19&#39;) bcr.bar_chart_race( df=df, filename=&#39;covid19_horiz_desc.mp4&#39;, orientation=&#39;h&#39;, sort=&#39;desc&#39;, n_bars=8, fixed_order=False, fixed_max=True, steps_per_period=10, period_length=500, interpolate_period=False, label_bars=True, bar_size=.95, period_label={&#39;x&#39;: .99, &#39;y&#39;: .8, &#39;ha&#39;: &#39;right&#39;, &#39;va&#39;: &#39;center&#39;}, period_fmt=&#39;%B %d, %Y&#39;, period_summary_func=lambda v, r: {&#39;x&#39;: .85, &#39;y&#39;: .2, &#39;s&#39;: f&#39;Total deaths: {v.sum()}&#39;, &#39;ha&#39;: &#39;right&#39;, &#39;size&#39;: 11}, perpendicular_bar_func=&#39;median&#39;, figsize=(5, 3), dpi=144, cmap=&#39;dark24&#39;, title=&#39;COVID-19 Deaths by Country&#39;, title_size=&#39;&#39;, bar_label_size=7, tick_label_size=7, shared_fontdict={&#39;family&#39; : &#39;Helvetica&#39;, &#39;weight&#39; : &#39;bold&#39;, &#39;color&#39; : &#39;.1&#39;}, scale=&#39;linear&#39;, writer=None, fig=None, bar_kwargs={&#39;alpha&#39;: .7}, filter_column_colors=False) Font Help --------- Font size can also be a string - &#39;xx-small&#39;, &#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;, &#39;large&#39;, &#39;x-large&#39;, &#39;xx-large&#39;, &#39;smaller&#39;, &#39;larger&#39; These sizes are relative to plt.rcParams[&#39;font.size&#39;]. &#39;&#39;&#39; bcr = _BarChartRace(df, filename, orientation, sort, n_bars, fixed_order, fixed_max, steps_per_period, period_length, interpolate_period, label_bars, bar_size, period_label, period_fmt, period_summary_func, perpendicular_bar_func, figsize, cmap, title, title_size, bar_label_size, tick_label_size, shared_fontdict, scale, writer, fig, dpi, bar_kwargs, filter_column_colors) return bcr.make_animation()</code></pre> def load_dataset ( name='covid19') Return a pandas DataFrame suitable for immediate use in bar_chart_race() . Must be connected to the internet Parameters name :\u2002 str , default 'covid19' Name of dataset to load. Either 'covid19' or 'urban_pop' Returns pandas DataFrame Expand source code def load_dataset(name='covid19'): ''' Return a pandas DataFrame suitable for immediate use in bar_chart_race . Must be connected to the internet Parameters ---------- name : str, default &#39;covid19&#39; Name of dataset to load. Either &#39;covid19&#39; or &#39;urban_pop&#39; Returns ------- pandas DataFrame &#39;&#39;&#39; url = f&#39;https://raw.githubusercontent.com/dexplo/bar_chart_race/master/data/{name}.csv&#39; index_dict = {&#39;covid19_tutorial&#39;: &#39;date&#39;, &#39;covid19&#39;: &#39;date&#39;, &#39;urban_pop&#39;: &#39;year&#39;} index_col = index_dict[name] return pd.read_csv(url, index_col=index_col, parse_dates=[index_col])</code></pre> def prepare_long_data ( df, index, columns, values, aggfunc='sum', orientation='h', sort='desc', n_bars=None, interpolate_period=False, steps_per_period=10, compute_ranks=True) Prepares 'long' data for bar chart animation. Returns two DataFrames - the interpolated values and the interpolated ranks You (currently) cannot pass long data to bar_chart_race() directly. Use this function to create your wide data first before passing it to bar_chart_race() . Parameters df :\u2002 pandas DataFrame Must be a 'long' pandas DataFrame where one column contains the period, another the categories, and the third the values of each category for each period. This DataFrame will be passed to the pivot_table method to turn it into a wide DataFrame. It will then be passed to the prepare_wide_data() function. index :\u2002 str Name of column used for the time period. It will be placed in the index columns :\u2002 str Name of column containing the categories for each time period. This column will get pivoted so that each unique value is a column. values :\u2002 str Name of column holding the values for each time period of each category. This column will become the values of the resulting DataFrame aggfunc :\u2002 str or aggregation function , default 'sum' String name of aggregation function ('sum', 'min', 'mean', 'max, etc\u2026) or actual function (np.sum, np.min, etc\u2026). Categories that have multiple values for the same time period must be aggregated for the animation to work. orientation :\u2002 'h' or 'v' , default 'h' Bar orientation - horizontal or vertical sort :\u2002 'desc' or 'asc' , default 'desc' Choose how to sort the bars. Use 'desc' to put largest bars on top and 'asc' to place largest bars on bottom. n_bars :\u2002 int , default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the bottom or top. interpolate_period :\u2002 bool , default False Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to True , for example, the two consecutive periods 2020-03-29 and 2020-03-30 with steps_per_period set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 steps_per_period :\u2002 int , default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. compute_ranks :\u2002 bool , default True When True return both the interpolated values and ranks DataFrames Otherwise just return the values Returns A tuple of DataFrames. The first is the interpolated values and the second is the interpolated ranks. Examples df_values, df_ranks = bcr.prepare_long_data(df) bcr.bar_chart_race(df_values, steps_per_period=1, period_length=50) Expand source code def prepare_long_data(df, index, columns, values, aggfunc='sum', orientation='h', sort='desc', n_bars=None, interpolate_period=False, steps_per_period=10, compute_ranks=True): ''' Prepares 'long' data for bar chart animation. Returns two DataFrames - the interpolated values and the interpolated ranks You (currently) cannot pass long data to `bar_chart_race` directly. Use this function to create your wide data first before passing it to `bar_chart_race`. Parameters ---------- df : pandas DataFrame Must be a &#39;long&#39; pandas DataFrame where one column contains the period, another the categories, and the third the values of each category for each period. This DataFrame will be passed to the `pivot_table` method to turn it into a wide DataFrame. It will then be passed to the `prepare_wide_data` function. index : str Name of column used for the time period. It will be placed in the index columns : str Name of column containing the categories for each time period. This column will get pivoted so that each unique value is a column. values : str Name of column holding the values for each time period of each category. This column will become the values of the resulting DataFrame aggfunc : str or aggregation function, default &#39;sum&#39; String name of aggregation function (&#39;sum&#39;, &#39;min&#39;, &#39;mean&#39;, &#39;max, etc...) or actual function (np.sum, np.min, etc...). Categories that have multiple values for the same time period must be aggregated for the animation to work. orientation : &#39;h&#39; or &#39;v&#39;, default &#39;h&#39; Bar orientation - horizontal or vertical sort : &#39;desc&#39; or &#39;asc&#39;, default &#39;desc&#39; Choose how to sort the bars. Use &#39;desc&#39; to put largest bars on top and &#39;asc&#39; to place largest bars on bottom. n_bars : int, default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the bottom or top. interpolate_period : bool, default `False` Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to `True`, for example, the two consecutive periods 2020-03-29 and 2020-03-30 with `steps_per_period` set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 steps_per_period : int, default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. compute_ranks : bool, default True When `True` return both the interpolated values and ranks DataFrames Otherwise just return the values Returns ------- A tuple of DataFrames. The first is the interpolated values and the second is the interpolated ranks. Examples -------- df_values, df_ranks = bcr.prepare_long_data(df) bcr.bar_chart_race(df_values, steps_per_period=1, period_length=50) &#39;&#39;&#39; df_wide = df.pivot_table(index=index, columns=columns, values=values, aggfunc=aggfunc) return prepare_wide_data(df_wide, orientation, sort, n_bars, interpolate_period, steps_per_period, compute_ranks)</code></pre> def prepare_wide_data ( df, orientation='h', sort='desc', n_bars=None, interpolate_period=False, steps_per_period=10, compute_ranks=True) Prepares 'wide' data for bar chart animation. Returns two DataFrames - the interpolated values and the interpolated ranks There is no need to use this function directly to create the animation. You can pass your DataFrame directly to bar_chart_race() . This function is useful if you want to view the prepared data without creating an animation. Parameters df :\u2002 pandas DataFrame Must be a 'wide' pandas DataFrame where each row represents a single period of time. Each column contains the values of the bars for that category. Optionally, use the index to label each time period. orientation :\u2002 'h' or 'v' , default 'h' Bar orientation - horizontal or vertical sort :\u2002 'desc' or 'asc' , default 'desc' Choose how to sort the bars. Use 'desc' to put largest bars on top and 'asc' to place largest bars on bottom. n_bars :\u2002 int , default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the bottom or top. interpolate_period :\u2002 bool , default False Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to True , for example, the two consecutive periods 2020-03-29 and 2020-03-30 with steps_per_period set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 steps_per_period :\u2002 int , default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. compute_ranks :\u2002 bool , default True When True return both the interpolated values and ranks DataFrames Otherwise just return the values Returns A tuple of DataFrames. The first is the interpolated values and the second is the interpolated ranks. Examples df_values, df_ranks = bcr.prepare_wide_data(df) Expand source code def prepare_wide_data(df, orientation='h', sort='desc', n_bars=None, interpolate_period=False, steps_per_period=10, compute_ranks=True): ''' Prepares 'wide' data for bar chart animation. Returns two DataFrames - the interpolated values and the interpolated ranks There is no need to use this function directly to create the animation. You can pass your DataFrame directly to `bar_chart_race`. This function is useful if you want to view the prepared data without creating an animation. Parameters ---------- df : pandas DataFrame Must be a &#39;wide&#39; pandas DataFrame where each row represents a single period of time. Each column contains the values of the bars for that category. Optionally, use the index to label each time period. orientation : &#39;h&#39; or &#39;v&#39;, default &#39;h&#39; Bar orientation - horizontal or vertical sort : &#39;desc&#39; or &#39;asc&#39;, default &#39;desc&#39; Choose how to sort the bars. Use &#39;desc&#39; to put largest bars on top and &#39;asc&#39; to place largest bars on bottom. n_bars : int, default None Choose the maximum number of bars to display on the graph. By default, use all bars. New bars entering the race will appear from the bottom or top. interpolate_period : bool, default `False` Whether to interpolate the period. Only valid for datetime or numeric indexes. When set to `True`, for example, the two consecutive periods 2020-03-29 and 2020-03-30 with `steps_per_period` set to 4 would yield a new index of 2020-03-29 00:00:00 2020-03-29 06:00:00 2020-03-29 12:00:00 2020-03-29 18:00:00 2020-03-30 00:00:00 steps_per_period : int, default 10 The number of steps to go from one time period to the next. The bars will grow linearly between each period. compute_ranks : bool, default True When `True` return both the interpolated values and ranks DataFrames Otherwise just return the values Returns ------- A tuple of DataFrames. The first is the interpolated values and the second is the interpolated ranks. Examples -------- df_values, df_ranks = bcr.prepare_wide_data(df) &#39;&#39;&#39; if n_bars is None: n_bars = df.shape[1] df_values = df.reset_index() df_values.index = df_values.index * steps_per_period new_index = range(df_values.index[-1] + 1) df_values = df_values.reindex(new_index) if interpolate_period: if df_values.iloc[:, 0].dtype.kind == &#39;M&#39;: first, last = df_values.iloc[[0, -1], 0] dr = pd.date_range(first, last, periods=len(df_values)) df_values.iloc[:, 0] = dr else: df_values.iloc[:, 0] = df_values.iloc[:, 0].interpolate() else: df_values.iloc[:, 0] = df_values.iloc[:, 0].fillna(method=&#39;ffill&#39;) df_values = df_values.set_index(df_values.columns[0]) if compute_ranks: df_ranks = df_values.rank(axis=1, method=&#39;first&#39;, ascending=False).clip(upper=n_bars + 1) if (sort == &#39;desc&#39; and orientation == &#39;h&#39;) or (sort == &#39;asc&#39; and orientation == &#39;v&#39;): df_ranks = n_bars + 1 - df_ranks df_ranks = df_ranks.interpolate() df_values = df_values.interpolate() if compute_ranks: return df_values, df_ranks return df_values</code></pre> Index Functions bar_chart_race load_dataset prepare_long_data prepare_wide_data Generated by pdoc 0.8.1 . hljs.initHighlightingOnLoad()","title":"API Reference"},{"location":"data_preparation/","text":"Data Preparation \u00b6 bar_chart_race exposes two functions, prepare_wide_data and prepare_long_data to transform pandas DataFrames to the correct form. Wide data \u00b6 To show how the prepare_wide_data function works, we'll read in the last three rows from the covid19_tutorial dataset. df = bcr . load_dataset ( 'covid19_tutorial' ) . tail ( 3 ) df Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629 This format of data is sometimes known as 'wide' data since each column contains data that all represents the same thing (deaths). Each new country would add an additional column to the DataFrame, making it wider. This is the type of data that the bar_chart_race function requires. The prepare_wide_data function is what bar_chart_race calls internally, so it isn't necessary to use directly. However, it is available so that you can view and understand how the data gets prepared. To transition the bars smoothly from one time period to the next, both the length of the bars and position are changed linearly. Two DataFrames of the same shape are returned - one for the values and the other for the ranks. df_values , df_ranks = bcr . prepare_wide_data ( df , steps_per_period = 4 , orientation = 'h' , sort = 'desc' ) Below, we have the df_values DataFrame containing the length of each bar for each frame. A total of four rows now exist for each period. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3019.00 3340.00 13215.00 2767.00 4232.00 18849.00 2520.00 16081.00 18595.00 8974.00 2020-04-10 3100.75 3340.75 13374.00 2798.75 4263.25 19003.75 2553.25 16212.25 19064.00 9203.50 2020-04-10 3182.50 3341.50 13533.00 2830.50 4294.50 19158.50 2586.50 16343.50 19533.00 9433.00 2020-04-10 3264.25 3342.25 13692.00 2862.25 4325.75 19313.25 2619.75 16474.75 20002.00 9662.50 2020-04-11 3346.00 3343.00 13851.00 2894.00 4357.00 19468.00 2653.00 16606.00 20471.00 9892.00 2020-04-11 3409.50 3343.00 13991.25 2926.00 4386.25 19575.75 2676.50 16756.75 20861.25 10076.25 2020-04-11 3473.00 3343.00 14131.50 2958.00 4415.50 19683.50 2700.00 16907.50 21251.50 10260.50 2020-04-11 3536.50 3343.00 14271.75 2990.00 4444.75 19791.25 2723.50 17058.25 21641.75 10444.75 2020-04-12 3600.00 3343.00 14412.00 3022.00 4474.00 19899.00 2747.00 17209.00 22032.00 10629.00 The df_ranks DataFrame contains the numerical ranking of each country and is used for the position of the bar along the y-axis (or x-axis when veritcal). Notice that there are two sets of bars that switch places. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3.00 4.00 7.0 2.0 5.0 10.00 1.0 8.0 9.00 6.0 2020-04-10 3.25 3.75 7.0 2.0 5.0 9.75 1.0 8.0 9.25 6.0 2020-04-10 3.50 3.50 7.0 2.0 5.0 9.50 1.0 8.0 9.50 6.0 2020-04-10 3.75 3.25 7.0 2.0 5.0 9.25 1.0 8.0 9.75 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-12 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 Don't use before animation \u00b6 There is no need to use this function before making the animation if you already have wide data. Pass the bar_chart_race function your original data. Long data \u00b6 'Long' data is a format for data where all values of the same kind are stored in a single column. Take a look at the baseball data below, which contains the cumulative number of home runs each of the top 20 home run hitters accumulated by year. df_baseball = bcr . load_dataset ( 'baseball' ) df_baseball name year hr 0 Hank Aaron 0 0 1 Barry Bonds 0 0 2 Jimmie Foxx 0 0 3 Ken Griffey 0 0 4 Reggie Jackson 0 0 ... ... ... ... 424 Jim Thome 18 541 425 Jim Thome 19 564 426 Jim Thome 20 589 427 Jim Thome 21 604 428 Jim Thome 22 612 Name, year, and home runs are each in a single column, contrasting with the wide data, where each column had the same type of data. Long data must be converted to wide data by pivoting categorical column and placing the period in the index. The prepare_long_data provides this functionality. It simply uses the pandas pivot_table method to pivot (and potentially aggregate) the data before passing it to prepare_wide_data . The same two DataFrames are returned. df_values , df_ranks = bcr . prepare_long_data ( df_baseball , index = 'year' , columns = 'name' , values = 'hr' , steps_per_period = 5 ) df_values . head ( 16 ) The linearly interpolated values for the first three seasons of each player: name Albert Pujols Alex Rodriguez Babe Ruth Barry Bonds ... Reggie Jackson Sammy Sosa Willie Mays Willie McCovey year 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 7.4 0.0 0.0 3.2 ... 0.2 0.8 4.0 2.6 0.0 14.8 0.0 0.0 6.4 ... 0.4 1.6 8.0 5.2 0.0 22.2 0.0 0.0 9.6 ... 0.6 2.4 12.0 7.8 0.0 29.6 0.0 0.0 12.8 ... 0.8 3.2 16.0 10.4 1.0 37.0 0.0 0.0 16.0 ... 1.0 4.0 20.0 13.0 1.0 43.8 1.0 0.8 21.0 ... 6.8 7.0 20.8 15.6 1.0 50.6 2.0 1.6 26.0 ... 12.6 10.0 21.6 18.2 1.0 57.4 3.0 2.4 31.0 ... 18.4 13.0 22.4 20.8 1.0 64.2 4.0 3.2 36.0 ... 24.2 16.0 23.2 23.4 2.0 71.0 5.0 4.0 41.0 ... 30.0 19.0 24.0 26.0 2.0 79.6 12.2 4.6 45.8 ... 39.4 21.0 32.2 29.6 2.0 88.2 19.4 5.2 50.6 ... 48.8 23.0 40.4 33.2 2.0 96.8 26.6 5.8 55.4 ... 58.2 25.0 48.6 36.8 2.0 105.4 33.8 6.4 60.2 ... 67.6 27.0 56.8 40.4 3.0 114.0 41.0 7.0 65.0 ... 77.0 29.0 65.0 44.0 The rankings change substantially during this time period. df_ranks . head ( 16 ) name Albert Pujols Alex Rodriguez Babe Ruth Barry Bonds ... Reggie Jackson Sammy Sosa Willie Mays Willie McCovey year 0.0 20.0 19.0 18.0 17.0 ... 4.0 3.0 2.0 1.0 0.0 19.8 16.0 15.0 17.0 ... 4.2 4.8 5.2 3.4 0.0 19.6 13.0 12.0 17.0 ... 4.4 6.6 8.4 5.8 0.0 19.4 10.0 9.0 17.0 ... 4.6 8.4 11.6 8.2 0.0 19.2 7.0 6.0 17.0 ... 4.8 10.2 14.8 10.6 1.0 19.0 4.0 3.0 17.0 ... 5.0 12.0 18.0 13.0 1.0 19.2 4.2 3.2 17.0 ... 6.6 11.2 16.6 12.8 1.0 19.4 4.4 3.4 17.0 ... 8.2 10.4 15.2 12.6 1.0 19.6 4.6 3.6 17.0 ... 9.8 9.6 13.8 12.4 1.0 19.8 4.8 3.8 17.0 ... 11.4 8.8 12.4 12.2 2.0 20.0 5.0 4.0 17.0 ... 13.0 8.0 11.0 12.0 2.0 20.0 5.6 3.6 16.6 ... 13.8 7.8 11.6 11.4 2.0 20.0 6.2 3.2 16.2 ... 14.6 7.6 12.2 10.8 2.0 20.0 6.8 2.8 15.8 ... 15.4 7.4 12.8 10.2 2.0 20.0 7.4 2.4 15.4 ... 16.2 7.2 13.4 9.6 3.0 20.0 8.0 2.0 15.0 ... 17.0 7.0 14.0 9.0 Usage before animation \u00b6 If you wish to use this function before an animation, set steps_per_period to 1. df_values , df_ranks = bcr . prepare_long_data ( df_baseball , index = 'year' , columns = 'name' , values = 'hr' , steps_per_period = 1 , orientation = 'h' , sort = 'desc' ) def period_summary ( values , ranks ): top2 = values . nlargest ( 2 ) leader = top2 . index [ 0 ] lead = top2 . iloc [ 0 ] - top2 . iloc [ 1 ] s = f ' { leader } by { lead : .0f } ' return { 's' : s , 'x' : . 95 , 'y' : . 07 , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df_values , period_length = 1000 , fixed_max = True , fixed_order = True , n_bars = 10 , figsize = ( 5 , 3 ), period_fmt = 'Season {x:,.0f} ' , title = 'Top 10 Home Run Hitters by Season Played' )","title":"Data Preparation"},{"location":"data_preparation/#data-preparation","text":"bar_chart_race exposes two functions, prepare_wide_data and prepare_long_data to transform pandas DataFrames to the correct form.","title":"Data Preparation"},{"location":"data_preparation/#wide-data","text":"To show how the prepare_wide_data function works, we'll read in the last three rows from the covid19_tutorial dataset. df = bcr . load_dataset ( 'covid19_tutorial' ) . tail ( 3 ) df Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629 This format of data is sometimes known as 'wide' data since each column contains data that all represents the same thing (deaths). Each new country would add an additional column to the DataFrame, making it wider. This is the type of data that the bar_chart_race function requires. The prepare_wide_data function is what bar_chart_race calls internally, so it isn't necessary to use directly. However, it is available so that you can view and understand how the data gets prepared. To transition the bars smoothly from one time period to the next, both the length of the bars and position are changed linearly. Two DataFrames of the same shape are returned - one for the values and the other for the ranks. df_values , df_ranks = bcr . prepare_wide_data ( df , steps_per_period = 4 , orientation = 'h' , sort = 'desc' ) Below, we have the df_values DataFrame containing the length of each bar for each frame. A total of four rows now exist for each period. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3019.00 3340.00 13215.00 2767.00 4232.00 18849.00 2520.00 16081.00 18595.00 8974.00 2020-04-10 3100.75 3340.75 13374.00 2798.75 4263.25 19003.75 2553.25 16212.25 19064.00 9203.50 2020-04-10 3182.50 3341.50 13533.00 2830.50 4294.50 19158.50 2586.50 16343.50 19533.00 9433.00 2020-04-10 3264.25 3342.25 13692.00 2862.25 4325.75 19313.25 2619.75 16474.75 20002.00 9662.50 2020-04-11 3346.00 3343.00 13851.00 2894.00 4357.00 19468.00 2653.00 16606.00 20471.00 9892.00 2020-04-11 3409.50 3343.00 13991.25 2926.00 4386.25 19575.75 2676.50 16756.75 20861.25 10076.25 2020-04-11 3473.00 3343.00 14131.50 2958.00 4415.50 19683.50 2700.00 16907.50 21251.50 10260.50 2020-04-11 3536.50 3343.00 14271.75 2990.00 4444.75 19791.25 2723.50 17058.25 21641.75 10444.75 2020-04-12 3600.00 3343.00 14412.00 3022.00 4474.00 19899.00 2747.00 17209.00 22032.00 10629.00 The df_ranks DataFrame contains the numerical ranking of each country and is used for the position of the bar along the y-axis (or x-axis when veritcal). Notice that there are two sets of bars that switch places. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-10 3.00 4.00 7.0 2.0 5.0 10.00 1.0 8.0 9.00 6.0 2020-04-10 3.25 3.75 7.0 2.0 5.0 9.75 1.0 8.0 9.25 6.0 2020-04-10 3.50 3.50 7.0 2.0 5.0 9.50 1.0 8.0 9.50 6.0 2020-04-10 3.75 3.25 7.0 2.0 5.0 9.25 1.0 8.0 9.75 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-11 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0 2020-04-12 4.00 3.00 7.0 2.0 5.0 9.00 1.0 8.0 10.00 6.0","title":"Wide data"},{"location":"data_preparation/#dont-use-before-animation","text":"There is no need to use this function before making the animation if you already have wide data. Pass the bar_chart_race function your original data.","title":"Don't use before animation"},{"location":"data_preparation/#long-data","text":"'Long' data is a format for data where all values of the same kind are stored in a single column. Take a look at the baseball data below, which contains the cumulative number of home runs each of the top 20 home run hitters accumulated by year. df_baseball = bcr . load_dataset ( 'baseball' ) df_baseball name year hr 0 Hank Aaron 0 0 1 Barry Bonds 0 0 2 Jimmie Foxx 0 0 3 Ken Griffey 0 0 4 Reggie Jackson 0 0 ... ... ... ... 424 Jim Thome 18 541 425 Jim Thome 19 564 426 Jim Thome 20 589 427 Jim Thome 21 604 428 Jim Thome 22 612 Name, year, and home runs are each in a single column, contrasting with the wide data, where each column had the same type of data. Long data must be converted to wide data by pivoting categorical column and placing the period in the index. The prepare_long_data provides this functionality. It simply uses the pandas pivot_table method to pivot (and potentially aggregate) the data before passing it to prepare_wide_data . The same two DataFrames are returned. df_values , df_ranks = bcr . prepare_long_data ( df_baseball , index = 'year' , columns = 'name' , values = 'hr' , steps_per_period = 5 ) df_values . head ( 16 ) The linearly interpolated values for the first three seasons of each player: name Albert Pujols Alex Rodriguez Babe Ruth Barry Bonds ... Reggie Jackson Sammy Sosa Willie Mays Willie McCovey year 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 7.4 0.0 0.0 3.2 ... 0.2 0.8 4.0 2.6 0.0 14.8 0.0 0.0 6.4 ... 0.4 1.6 8.0 5.2 0.0 22.2 0.0 0.0 9.6 ... 0.6 2.4 12.0 7.8 0.0 29.6 0.0 0.0 12.8 ... 0.8 3.2 16.0 10.4 1.0 37.0 0.0 0.0 16.0 ... 1.0 4.0 20.0 13.0 1.0 43.8 1.0 0.8 21.0 ... 6.8 7.0 20.8 15.6 1.0 50.6 2.0 1.6 26.0 ... 12.6 10.0 21.6 18.2 1.0 57.4 3.0 2.4 31.0 ... 18.4 13.0 22.4 20.8 1.0 64.2 4.0 3.2 36.0 ... 24.2 16.0 23.2 23.4 2.0 71.0 5.0 4.0 41.0 ... 30.0 19.0 24.0 26.0 2.0 79.6 12.2 4.6 45.8 ... 39.4 21.0 32.2 29.6 2.0 88.2 19.4 5.2 50.6 ... 48.8 23.0 40.4 33.2 2.0 96.8 26.6 5.8 55.4 ... 58.2 25.0 48.6 36.8 2.0 105.4 33.8 6.4 60.2 ... 67.6 27.0 56.8 40.4 3.0 114.0 41.0 7.0 65.0 ... 77.0 29.0 65.0 44.0 The rankings change substantially during this time period. df_ranks . head ( 16 ) name Albert Pujols Alex Rodriguez Babe Ruth Barry Bonds ... Reggie Jackson Sammy Sosa Willie Mays Willie McCovey year 0.0 20.0 19.0 18.0 17.0 ... 4.0 3.0 2.0 1.0 0.0 19.8 16.0 15.0 17.0 ... 4.2 4.8 5.2 3.4 0.0 19.6 13.0 12.0 17.0 ... 4.4 6.6 8.4 5.8 0.0 19.4 10.0 9.0 17.0 ... 4.6 8.4 11.6 8.2 0.0 19.2 7.0 6.0 17.0 ... 4.8 10.2 14.8 10.6 1.0 19.0 4.0 3.0 17.0 ... 5.0 12.0 18.0 13.0 1.0 19.2 4.2 3.2 17.0 ... 6.6 11.2 16.6 12.8 1.0 19.4 4.4 3.4 17.0 ... 8.2 10.4 15.2 12.6 1.0 19.6 4.6 3.6 17.0 ... 9.8 9.6 13.8 12.4 1.0 19.8 4.8 3.8 17.0 ... 11.4 8.8 12.4 12.2 2.0 20.0 5.0 4.0 17.0 ... 13.0 8.0 11.0 12.0 2.0 20.0 5.6 3.6 16.6 ... 13.8 7.8 11.6 11.4 2.0 20.0 6.2 3.2 16.2 ... 14.6 7.6 12.2 10.8 2.0 20.0 6.8 2.8 15.8 ... 15.4 7.4 12.8 10.2 2.0 20.0 7.4 2.4 15.4 ... 16.2 7.2 13.4 9.6 3.0 20.0 8.0 2.0 15.0 ... 17.0 7.0 14.0 9.0","title":"Long data"},{"location":"data_preparation/#usage-before-animation","text":"If you wish to use this function before an animation, set steps_per_period to 1. df_values , df_ranks = bcr . prepare_long_data ( df_baseball , index = 'year' , columns = 'name' , values = 'hr' , steps_per_period = 1 , orientation = 'h' , sort = 'desc' ) def period_summary ( values , ranks ): top2 = values . nlargest ( 2 ) leader = top2 . index [ 0 ] lead = top2 . iloc [ 0 ] - top2 . iloc [ 1 ] s = f ' { leader } by { lead : .0f } ' return { 's' : s , 'x' : . 95 , 'y' : . 07 , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df_values , period_length = 1000 , fixed_max = True , fixed_order = True , n_bars = 10 , figsize = ( 5 , 3 ), period_fmt = 'Season {x:,.0f} ' , title = 'Top 10 Home Run Hitters by Season Played' )","title":"Usage before animation"},{"location":"installation/","text":"Installation \u00b6 Install from pypi or conda-forge pip install bar_chart_race conda install -c conda-forge bar_chart_race Installing ffmpeg \u00b6 In order to save animations as mp4/m4v/mov/etc... files, you must install ffmpeg , which allows for conversion to many different formats of video and audio. After installation, ensure that ffmpeg has been added to your path by going to your command line and entering ffmepg -version . Install ImageMagick for animated gifs \u00b6 If you desire to create animated gifs, you'll need to install ImageMagick . Verify that it has been added to your path with magick -version . Dependencies \u00b6 Bar Chart Race requires that you have both matplotlib and pandas installed.","title":"Installation"},{"location":"installation/#installation","text":"Install from pypi or conda-forge pip install bar_chart_race conda install -c conda-forge bar_chart_race","title":"Installation"},{"location":"installation/#installing-ffmpeg","text":"In order to save animations as mp4/m4v/mov/etc... files, you must install ffmpeg , which allows for conversion to many different formats of video and audio. After installation, ensure that ffmpeg has been added to your path by going to your command line and entering ffmepg -version .","title":"Installing ffmpeg"},{"location":"installation/#install-imagemagick-for-animated-gifs","text":"If you desire to create animated gifs, you'll need to install ImageMagick . Verify that it has been added to your path with magick -version .","title":"Install ImageMagick for animated gifs"},{"location":"installation/#dependencies","text":"Bar Chart Race requires that you have both matplotlib and pandas installed.","title":"Dependencies"},{"location":"tutorial/","text":"Tutorial \u00b6 bar_chart_race offers a wide range of inputs to customize the animation. On this page, we'll cover many of the available options. Data format \u00b6 The data you choose to animate as a bar chart race must be provided in a specific format. The data must be within a pandas DataFrame containing 'wide' data where: Each row represents a single period of time Each column holds the value for a particular category The index contains the time component (optional) Example data \u00b6 The data below is an example of properly formatted data. It shows total deaths from COVID-19 for several countries by date. Each row represents a single day's worth of data. Each column represents a single country's deaths. The index contains the date. Any pandas DataFrame that conforms to this structure may be used to create a bar chart race. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-08 2240 3337 10887 2349 3993 17669 2255 14792 14704 7111 2020-04-09 2523 3339 12228 2607 4110 18279 2403 15447 16553 7993 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629 Basic bar chart races \u00b6 A single main function, bar_chart_race , exists to create the animations. Calling it with the defaults returns the animation as an HTML string. The load_dataset function is available to load sample DataFrames. If you are working within a Jupyter Notebook, it will automatically be embedded in the output as a video. import bar_chart_race as bcr df = bcr . load_dataset ( 'covid19_tutorial' ) bcr . bar_chart_race ( df ) Vertical bars \u00b6 By default, bars are horizontal. Use the orientation parameter to switch it to vertical. bcr . bar_chart_race ( df , orientation = 'v' ) Ascending bars \u00b6 By default, the bars are plotted in descending order. Change the order by setting sort to 'asc' . bcr . bar_chart_race ( df , sort = 'asc' ) Limit the number of bars \u00b6 By default, all columns will be plotted. Use n_bars to limit the number. When limiting bars, the smallest bar can drop off the plot. bcr . bar_chart_race ( df , n_bars = 6 ) Fix the order of the bars \u00b6 By default, the bars will be ordered. Set fixed_order to True or to a specific list of column names to keep the order the same throughout. bcr . bar_chart_race ( df , fixed_order = [ 'Iran' , 'USA' , 'Italy' , 'Spain' , 'Belgium' ]) Fix the maximum value \u00b6 By default, the maximum value of the axis moves with the largest bar. Set fixed_max to True to keep the maximum value equal to the largest overall value for all frames in the animation. bcr . bar_chart_race ( df , fixed_max = True ) Change animation smoothness \u00b6 By default, 10 frames are used to step from one period to the next. Increase/decrease the smoothness of the animation with steps_per_period . bcr . bar_chart_race ( df , steps_per_period = 3 ) You may also change the amount of time per period with period_length , which is set to 500 milliseconds (half of a second) by default. bcr . bar_chart_race ( df , steps_per_period = 20 , period_length = 200 ) Interpolate the period \u00b6 By default, the label for each frame changes after the entire period has been plotted. Linearly interpolate the value for the period with interpolate_period . Below, every frame increase by 1 / 10 of a day (2 hours and 24 minutes). bcr . bar_chart_race ( df , interpolate_period = True ) Plot properties \u00b6 Many properties of the plot can be set. figsize - sets the figure size using matplotlib figure inches (default: (6, 3.5) ) dpi - controls the dots per square inch (default: 144 ) label_bars - whether to label the bar values with text (default: True ) period_label - dictionary of matplotlib text properties or boolean (default: True ) title - title of plot bcr . bar_chart_race ( df , figsize = ( 5 , 3 ), dpi = 100 , label_bars = False , period_label = { 'x' : . 99 , 'y' : . 1 , 'ha' : 'right' , 'color' : 'red' }, title = 'COVID-19 Deaths by Country' ) Label sizes \u00b6 Control the size of labels with bar_label_size , tick_label_size , and title_size . bcr . bar_chart_race ( df , bar_label_size = 4 , tick_label_size = 5 , title = 'COVID-19 Deaths by Country' , title_size = 'smaller' ) Setting font properties \u00b6 Set font properties for all text objects with shared_fontdict . bcr . bar_chart_race ( df , title = 'COVID-19 Deaths by Country' , shared_fontdict = { 'family' : 'Helvetica' , 'weight' : 'bold' , 'color' : 'rebeccapurple' }) Customize bar properties \u00b6 Set bar_kwargs to a dictionary of keyword arguments forwarded to the matploblib bar function to control bar properties. bcr . bar_chart_race ( df , bar_kwargs = { 'alpha' : . 2 , 'ec' : 'black' , 'lw' : 3 }) Additional features \u00b6 There are several more additional features to customize the animation. Formatting the period \u00b6 Format the label of the period by setting period_fmt to a string with either a date directive or a new-style formatted string. bcr . bar_chart_race ( df , period_fmt = '%b %-d , %Y' ) Use numbers for the index instead of dates \u00b6 It's not necessary to have dates or times in the index of the DataFrame. Below, the index is dropped, which replaces it with integers beginning at 0. These are then interpolated and formatted. bcr . bar_chart_race ( df . reset_index ( drop = True ), interpolate_period = True , period_fmt = 'Index value - {x:.2f} ' ) Add text summarizing the entire period \u00b6 Define a function that accepts two arguments, the values and ranks of the current period of data, and returns a dictionary that will be passed to the matplotlib text function. def summary ( values , ranks ): total_deaths = int ( round ( values . sum (), - 2 )) s = f 'Total Deaths - { total_deaths : ,.0f } ' return { 'x' : . 99 , 'y' : . 05 , 's' : s , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df , period_summary_func = summary ) Add a perpendicular bar \u00b6 Add a single bar perpendicular to the main bars by defining a function that accepts two arguments, the values and ranks of the current period of data, and returns a single number, the position of the bar. You can use string names of aggregation functions that pandas understands. bcr . bar_chart_race ( df , perpendicular_bar_func = 'mean' ) An example with a user-defined function: def func ( values , ranks ): return values . quantile ( . 9 ) bcr . bar_chart_race ( df , perpendicular_bar_func = func ) Bar colors \u00b6 By default, the 'dark12' colormap is used, with 12 unique colors. This is a qualitative color map containing every other color from the 'dark24' colormap originally found from the plotly express documentation . All matplotlib and plotly colormaps are available by name. The entire 'dark24' colormap will be used by default when your DataFrame contains more than 12 columns. bcr . bar_chart_race ( df , cmap = 'antique' ) Reduce color repetition \u00b6 It is possible that some colors repeat in your animation, even if there are more colors in the colormap than bars in the animation. This will only happen if you set the n_bars parameter, as colors are assigned to each column upon. You'll get a warning advising you to set filter_column_colors to True , which will only assign colors to those bars appearing in the animation. The following example uses the Accent colormap which has 8 unique colors. The animation is set to have a maximum of 7 bars, but there are still repeating colors. bcr . bar_chart_race ( df , cmap = 'accent' , n_bars = 7 ) UserWarning Some of your columns never make an appearance in the animation. To reduce color repetition, set filter_column_colors to True Setting filter_column_colors to True will reduce the likelihood of repeating colors, but will still happen if the total number of unique bars is more than the number of colors in the colormap. bcr . bar_chart_race ( df , cmap = 'accent' , n_bars = 7 , filter_column_colors = True ) Using your own figure \u00b6 If you want to highly customize the animation, set the fig parameter to a previously created figure. This figure must have at aleast one matplotlib axes created within it. fig , ax = plt . subplots ( figsize = ( 5 , 2 ), dpi = 120 ) ax . set_facecolor (( 0 , 0 , 1 , . 3 )) bcr . bar_chart_race ( df , n_bars = 3 , fig = fig ) With subplots \u00b6 It's possible to add an animation to a matplotlib figure containing multiple subplots. The first subplot will be used for the animation. from matplotlib import dates fig , ax_array = plt . subplots ( 2 , 2 , figsize = ( 8 , 4 ), dpi = 120 , tight_layout = True ) ax1 , ax2 , ax3 , ax4 = ax_array . flatten () fig . suptitle ( 'Animation in First Axes' , y = 1 ) ax2 . plot ( df ) ax2 . xaxis . set_major_locator ( dates . DayLocator ([ 3 , 7 , 12 ])) ax3 . bar ( df . index , df . median ( axis = 1 )) ax3 . xaxis . set_major_locator ( dates . DayLocator ([ 3 , 7 , 12 ])) ax4 . pie ( df . iloc [ - 1 ], radius = 1.5 , labels = df . columns ) bcr . bar_chart_race ( df , n_bars = 3 , fig = fig ) Saving the animation \u00b6 Default returned values \u00b6 By default, the video will be embedded into your Jupyter Notebook. If you are not in a Jupyter Notebook, but have IPython installed, an HTML object will be returned. Retrieve the underlying HTML with the data attribute. html = bcr . bar_chart_race ( df ) html . data # very long string of HTML If you do not have IPython installed, then a string of HTML will be returned directly. Saving to disk \u00b6 In order to save the animation to disk, use a string of the file name of where you'd like to save as the second argument. You'll need to install ffmpeg first in order to save the animation. Once installed, you'll be able to save the animation as a wide variety of formats (mp4, m4v, mov, etc...). To save the animation as a gif, install ImageMagick. bcr.bar_chart_race(df, 'docs/videos/covid19.mp4', figsize=(5, 3)) Matplotlib writer \u00b6 To customize the animation, set the writer parameter to a matplotlib MovieWriter object instance.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"bar_chart_race offers a wide range of inputs to customize the animation. On this page, we'll cover many of the available options.","title":"Tutorial"},{"location":"tutorial/#data-format","text":"The data you choose to animate as a bar chart race must be provided in a specific format. The data must be within a pandas DataFrame containing 'wide' data where: Each row represents a single period of time Each column holds the value for a particular category The index contains the time component (optional)","title":"Data format"},{"location":"tutorial/#example-data","text":"The data below is an example of properly formatted data. It shows total deaths from COVID-19 for several countries by date. Each row represents a single day's worth of data. Each column represents a single country's deaths. The index contains the date. Any pandas DataFrame that conforms to this structure may be used to create a bar chart race. Belgium China France Germany Iran Italy Netherlands Spain USA United Kingdom date 2020-04-08 2240 3337 10887 2349 3993 17669 2255 14792 14704 7111 2020-04-09 2523 3339 12228 2607 4110 18279 2403 15447 16553 7993 2020-04-10 3019 3340 13215 2767 4232 18849 2520 16081 18595 8974 2020-04-11 3346 3343 13851 2894 4357 19468 2653 16606 20471 9892 2020-04-12 3600 3343 14412 3022 4474 19899 2747 17209 22032 10629","title":"Example data"},{"location":"tutorial/#basic-bar-chart-races","text":"A single main function, bar_chart_race , exists to create the animations. Calling it with the defaults returns the animation as an HTML string. The load_dataset function is available to load sample DataFrames. If you are working within a Jupyter Notebook, it will automatically be embedded in the output as a video. import bar_chart_race as bcr df = bcr . load_dataset ( 'covid19_tutorial' ) bcr . bar_chart_race ( df )","title":"Basic bar chart races"},{"location":"tutorial/#vertical-bars","text":"By default, bars are horizontal. Use the orientation parameter to switch it to vertical. bcr . bar_chart_race ( df , orientation = 'v' )","title":"Vertical bars"},{"location":"tutorial/#ascending-bars","text":"By default, the bars are plotted in descending order. Change the order by setting sort to 'asc' . bcr . bar_chart_race ( df , sort = 'asc' )","title":"Ascending bars"},{"location":"tutorial/#limit-the-number-of-bars","text":"By default, all columns will be plotted. Use n_bars to limit the number. When limiting bars, the smallest bar can drop off the plot. bcr . bar_chart_race ( df , n_bars = 6 )","title":"Limit the number of bars"},{"location":"tutorial/#fix-the-order-of-the-bars","text":"By default, the bars will be ordered. Set fixed_order to True or to a specific list of column names to keep the order the same throughout. bcr . bar_chart_race ( df , fixed_order = [ 'Iran' , 'USA' , 'Italy' , 'Spain' , 'Belgium' ])","title":"Fix the order of the bars"},{"location":"tutorial/#fix-the-maximum-value","text":"By default, the maximum value of the axis moves with the largest bar. Set fixed_max to True to keep the maximum value equal to the largest overall value for all frames in the animation. bcr . bar_chart_race ( df , fixed_max = True )","title":"Fix the maximum value"},{"location":"tutorial/#change-animation-smoothness","text":"By default, 10 frames are used to step from one period to the next. Increase/decrease the smoothness of the animation with steps_per_period . bcr . bar_chart_race ( df , steps_per_period = 3 ) You may also change the amount of time per period with period_length , which is set to 500 milliseconds (half of a second) by default. bcr . bar_chart_race ( df , steps_per_period = 20 , period_length = 200 )","title":"Change animation smoothness"},{"location":"tutorial/#interpolate-the-period","text":"By default, the label for each frame changes after the entire period has been plotted. Linearly interpolate the value for the period with interpolate_period . Below, every frame increase by 1 / 10 of a day (2 hours and 24 minutes). bcr . bar_chart_race ( df , interpolate_period = True )","title":"Interpolate the period"},{"location":"tutorial/#plot-properties","text":"Many properties of the plot can be set. figsize - sets the figure size using matplotlib figure inches (default: (6, 3.5) ) dpi - controls the dots per square inch (default: 144 ) label_bars - whether to label the bar values with text (default: True ) period_label - dictionary of matplotlib text properties or boolean (default: True ) title - title of plot bcr . bar_chart_race ( df , figsize = ( 5 , 3 ), dpi = 100 , label_bars = False , period_label = { 'x' : . 99 , 'y' : . 1 , 'ha' : 'right' , 'color' : 'red' }, title = 'COVID-19 Deaths by Country' )","title":"Plot properties"},{"location":"tutorial/#label-sizes","text":"Control the size of labels with bar_label_size , tick_label_size , and title_size . bcr . bar_chart_race ( df , bar_label_size = 4 , tick_label_size = 5 , title = 'COVID-19 Deaths by Country' , title_size = 'smaller' )","title":"Label sizes"},{"location":"tutorial/#setting-font-properties","text":"Set font properties for all text objects with shared_fontdict . bcr . bar_chart_race ( df , title = 'COVID-19 Deaths by Country' , shared_fontdict = { 'family' : 'Helvetica' , 'weight' : 'bold' , 'color' : 'rebeccapurple' })","title":"Setting font properties"},{"location":"tutorial/#customize-bar-properties","text":"Set bar_kwargs to a dictionary of keyword arguments forwarded to the matploblib bar function to control bar properties. bcr . bar_chart_race ( df , bar_kwargs = { 'alpha' : . 2 , 'ec' : 'black' , 'lw' : 3 })","title":"Customize bar properties"},{"location":"tutorial/#additional-features","text":"There are several more additional features to customize the animation.","title":"Additional features"},{"location":"tutorial/#formatting-the-period","text":"Format the label of the period by setting period_fmt to a string with either a date directive or a new-style formatted string. bcr . bar_chart_race ( df , period_fmt = '%b %-d , %Y' )","title":"Formatting the period"},{"location":"tutorial/#use-numbers-for-the-index-instead-of-dates","text":"It's not necessary to have dates or times in the index of the DataFrame. Below, the index is dropped, which replaces it with integers beginning at 0. These are then interpolated and formatted. bcr . bar_chart_race ( df . reset_index ( drop = True ), interpolate_period = True , period_fmt = 'Index value - {x:.2f} ' )","title":"Use numbers for the index instead of dates"},{"location":"tutorial/#add-text-summarizing-the-entire-period","text":"Define a function that accepts two arguments, the values and ranks of the current period of data, and returns a dictionary that will be passed to the matplotlib text function. def summary ( values , ranks ): total_deaths = int ( round ( values . sum (), - 2 )) s = f 'Total Deaths - { total_deaths : ,.0f } ' return { 'x' : . 99 , 'y' : . 05 , 's' : s , 'ha' : 'right' , 'size' : 8 } bcr . bar_chart_race ( df , period_summary_func = summary )","title":"Add text summarizing the entire period"},{"location":"tutorial/#add-a-perpendicular-bar","text":"Add a single bar perpendicular to the main bars by defining a function that accepts two arguments, the values and ranks of the current period of data, and returns a single number, the position of the bar. You can use string names of aggregation functions that pandas understands. bcr . bar_chart_race ( df , perpendicular_bar_func = 'mean' ) An example with a user-defined function: def func ( values , ranks ): return values . quantile ( . 9 ) bcr . bar_chart_race ( df , perpendicular_bar_func = func )","title":"Add a perpendicular bar"},{"location":"tutorial/#bar-colors","text":"By default, the 'dark12' colormap is used, with 12 unique colors. This is a qualitative color map containing every other color from the 'dark24' colormap originally found from the plotly express documentation . All matplotlib and plotly colormaps are available by name. The entire 'dark24' colormap will be used by default when your DataFrame contains more than 12 columns. bcr . bar_chart_race ( df , cmap = 'antique' )","title":"Bar colors"},{"location":"tutorial/#reduce-color-repetition","text":"It is possible that some colors repeat in your animation, even if there are more colors in the colormap than bars in the animation. This will only happen if you set the n_bars parameter, as colors are assigned to each column upon. You'll get a warning advising you to set filter_column_colors to True , which will only assign colors to those bars appearing in the animation. The following example uses the Accent colormap which has 8 unique colors. The animation is set to have a maximum of 7 bars, but there are still repeating colors. bcr . bar_chart_race ( df , cmap = 'accent' , n_bars = 7 ) UserWarning Some of your columns never make an appearance in the animation. To reduce color repetition, set filter_column_colors to True Setting filter_column_colors to True will reduce the likelihood of repeating colors, but will still happen if the total number of unique bars is more than the number of colors in the colormap. bcr . bar_chart_race ( df , cmap = 'accent' , n_bars = 7 , filter_column_colors = True )","title":"Reduce color repetition"},{"location":"tutorial/#using-your-own-figure","text":"If you want to highly customize the animation, set the fig parameter to a previously created figure. This figure must have at aleast one matplotlib axes created within it. fig , ax = plt . subplots ( figsize = ( 5 , 2 ), dpi = 120 ) ax . set_facecolor (( 0 , 0 , 1 , . 3 )) bcr . bar_chart_race ( df , n_bars = 3 , fig = fig )","title":"Using your own figure"},{"location":"tutorial/#with-subplots","text":"It's possible to add an animation to a matplotlib figure containing multiple subplots. The first subplot will be used for the animation. from matplotlib import dates fig , ax_array = plt . subplots ( 2 , 2 , figsize = ( 8 , 4 ), dpi = 120 , tight_layout = True ) ax1 , ax2 , ax3 , ax4 = ax_array . flatten () fig . suptitle ( 'Animation in First Axes' , y = 1 ) ax2 . plot ( df ) ax2 . xaxis . set_major_locator ( dates . DayLocator ([ 3 , 7 , 12 ])) ax3 . bar ( df . index , df . median ( axis = 1 )) ax3 . xaxis . set_major_locator ( dates . DayLocator ([ 3 , 7 , 12 ])) ax4 . pie ( df . iloc [ - 1 ], radius = 1.5 , labels = df . columns ) bcr . bar_chart_race ( df , n_bars = 3 , fig = fig )","title":"With subplots"},{"location":"tutorial/#saving-the-animation","text":"","title":"Saving the animation"},{"location":"tutorial/#default-returned-values","text":"By default, the video will be embedded into your Jupyter Notebook. If you are not in a Jupyter Notebook, but have IPython installed, an HTML object will be returned. Retrieve the underlying HTML with the data attribute. html = bcr . bar_chart_race ( df ) html . data # very long string of HTML If you do not have IPython installed, then a string of HTML will be returned directly.","title":"Default returned values"},{"location":"tutorial/#saving-to-disk","text":"In order to save the animation to disk, use a string of the file name of where you'd like to save as the second argument. You'll need to install ffmpeg first in order to save the animation. Once installed, you'll be able to save the animation as a wide variety of formats (mp4, m4v, mov, etc...). To save the animation as a gif, install ImageMagick. bcr.bar_chart_race(df, 'docs/videos/covid19.mp4', figsize=(5, 3))","title":"Saving to disk"},{"location":"tutorial/#matplotlib-writer","text":"To customize the animation, set the writer parameter to a matplotlib MovieWriter object instance.","title":"Matplotlib writer"},{"location":"upcoming/","text":"Upcoming Features \u00b6 Support for Plotly animations Images within the bars Names within bars (as opposed to just tick labels) Tools to see colormaps Request a feature \u00b6 Request a feature by creating an issue on github .","title":"Upcoming Features"},{"location":"upcoming/#upcoming-features","text":"Support for Plotly animations Images within the bars Names within bars (as opposed to just tick labels) Tools to see colormaps","title":"Upcoming Features"},{"location":"upcoming/#request-a-feature","text":"Request a feature by creating an issue on github .","title":"Request a feature"},{"location":"whats_new/","text":"What's New \u00b6 Version 0.1 \u00b6 Released June 1, 2020 This is the first major release of bar_chart_race adding many features: Fixed bar position Fixed max value Perpendicular bars Interpolation of the period Formatting of the period label Period label summary Support for plotly colormaps Version 0.0.1 \u00b6 Released April 29, 2020 Genesis of bar_chart_race capable of producing smoothly transitioning bars with matplotlib and pandas.","title":"What's New"},{"location":"whats_new/#whats-new","text":"","title":"What's New"},{"location":"whats_new/#version-01","text":"Released June 1, 2020 This is the first major release of bar_chart_race adding many features: Fixed bar position Fixed max value Perpendicular bars Interpolation of the period Formatting of the period label Period label summary Support for plotly colormaps","title":"Version 0.1"},{"location":"whats_new/#version-001","text":"Released April 29, 2020 Genesis of bar_chart_race capable of producing smoothly transitioning bars with matplotlib and pandas.","title":"Version 0.0.1"}]}